import React, { useRef } from 'react';
import { FeatureGroup } from 'react-leaflet';
import { EditControl } from 'react-leaflet-draw';
import Swal from 'sweetalert2';
import axios from 'axios';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import 'leaflet-draw/dist/leaflet.draw.css';
import './geofencepopup.css';

const MapWithDraw = () => {
  const featureGroupRef = useRef(null);

  const handleCreated = (e) => {
    const { layer } = e;

    if (layer instanceof L.Polygon 
      || layer instanceof L.Circle || layer instanceof L.Polyline
    ) {
      const popupContent = document.createElement('div');
      const todayDate = new Date().toISOString().split('T')[0];
      const autoGeneratedGeofenceId = `GF-${Math.random().toString(36).substr(2, 9).toUpperCase()}`;

      popupContent.innerHTML = `
        <form id="popup-form" style="width: 250px; display: flex; flex-direction: column;">
          <div class="property-row">
            <label for="geofence-id">Geofence ID:</label>
            <input type="text" id="geofence-id" value="${autoGeneratedGeofenceId}" class="property-id" disabled />
          </div>
          <div class="property-row">
            <label for="geofence-name">Geofence Name:</label>
            <input type="text" id="geofence-name" class="property-name" placeholder="Enter Geofence Name" required />
          </div>
          <div class="property-row">
            <label for="geofence-type">Geofence Type:</label>
            <select id="geofence-type" class="geofence-type" required>
              <option value="" disabled selected>Select Type</option>
              <option value="global">Global</option>
              <option value="vessel">Vessel</option>
              <option value="port">Port</option>
            </select>
          </div>
          <div class="property-row">
            <label for="date">Date:</label>
            <input type="date" id="date" value="${todayDate}" disabled />
          </div>
          <div class="property-row">
            <label for="remarks">Remarks:</label>
            <textarea id="remarks" class="remarks" placeholder="Enter description" required></textarea>
          </div>
          <div class="buttons-row" style="display: flex; justify-content: space-between;">
            <button type="button" id="cancel-btn" class="cancel-btn">Cancel</button>
            <button type="submit" class="submit-btn">Save</button>
          </div>
        </form>
      `;

      layer.bindPopup(popupContent).openPopup();

      const observer = new MutationObserver(() => {
        if (popupContent.querySelector('#popup-form')) {
          observer.disconnect();

          const form = popupContent.querySelector('#popup-form');
          const cancelBtn = popupContent.querySelector('#cancel-btn');

          form.addEventListener('submit', async (event) => {
            event.preventDefault();

            let coordinates;
            if (layer instanceof L.Circle) {
              const center = layer.getLatLng();
              const radius = layer.getRadius();
              if (radius <= 0) {
                Swal.fire('Error', 'Circle radius must be greater than zero.', 'error');
                return;
              }
              coordinates = [{ lat: center.lat, lng: center.lng, radius }];
            } else 
            
            if (layer instanceof L.Polygon) {
              coordinates = layer.getLatLngs()[0].map(latlng => {
                console.log('Polygon Coordinate:', { lat: latlng.lat, lng: latlng.lng }); // Log each coordinate
                return { lat: latlng.lng, lng: latlng.lat };
              });
            } 
            else if (layer instanceof L.Polyline) {
              coordinates = layer.getLatLngs().map(latlng => {
                console.log('Polyline Coordinate:', { lat: latlng.lat, lng: latlng.lng }); // Log each coordinate
                return { lat: latlng.lat, lng: latlng.lng };
              });
            }

            const formData = {
              geofenceId: form.querySelector('#geofence-id').value,
              geofenceName: form.querySelector('#geofence-name').value,
              geofenceType: form.querySelector('#geofence-type').value,
              date: form.querySelector('#date').value,
              remarks: form.querySelector('#remarks').value,
              coordinates,
            };

            if (!formData.geofenceName || !formData.geofenceType || !formData.remarks) {
              Swal.fire('Error', 'Please fill out all fields!', 'error');
              return;
            }

            try {
              const endpoint = layer instanceof L.Polygon
                ? 'http://localhost:5000/api/addpolygongeofences'
                : layer instanceof L.Circle
                ? 'http://localhost:5000/api/addcirclegeofences'
                : 'http://localhost:5000/api/addpolylinegeofences';

              const response = await axios.post(endpoint, formData);

              if (response.status === 201) {
                Swal.fire('Success', 'Geofence saved successfully!', 'success').then(() => {
                  layer.closePopup();
                });
              } else {
                throw new Error('Unexpected response status: ' + response.status);
              }
            } catch (error) {
              console.error('Error saving geofence:', error);
              Swal.fire('Error', 'Failed to save geofence data. ' + (error.response?.data?.error || 'Please try again.'), 'error');
            }
          });

          cancelBtn.addEventListener('click', () => {
            layer.closePopup();
          });
        }
      });

      observer.observe(popupContent, { childList: true, subtree: true });
    }
  };

  return (
    <FeatureGroup ref={featureGroupRef}>
      <EditControl
        position="topright"
        onCreated={handleCreated}
        draw={{
          rectangle: false,
          marker: false,
          circlemarker: false,
          polygon: true,
          polyline: true,
          circle: true,
        }}
      />
    </FeatureGroup>
  );
};

export default MapWithDraw;
